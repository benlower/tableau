<html>
<head>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script type="text/javascript">

function init() {
  tableau.connectionName = 'XML data';
  tableau.initCallback();
}

function shutdown() {
    tableau.shutdownCallback();
}

function getColumnHeaders() {
  _retrieveXmlData(function (tableData) {
    var headers = tableData.headers;
    var fieldNames = [];
    var fieldTypes = [];

    for (var fieldName in headers) {
      if (headers.hasOwnProperty(fieldName)) {
        fieldNames.push(fieldName);
        fieldTypes.push(headers[fieldName]);
      }
    }
    tableau.headersCallback(fieldNames, fieldTypes); // tell tableau about the fields and their types
  });
}
    
function getTableData(lastRecordNumber) {
  if (lastRecordNumber) {
    // used for larger data sets. Just return for now.
    tableau.dataCallback([], 0);
    return;
  }

  _retrieveXmlData(function (tableData) {
    var rowData = tableData.rowData;
    tableau.dataCallback(rowData, rowData.length);
  });
}

function _retrieveXmlData(retrieveDataCallback) {
  if (!window.cachedTableData) {
    var conData = JSON.parse(tableau.connectionData);
    var xmlString = conData.xmlString;
    if (conData.xmlUrl) {
      // handle the xml data from the remote source.      
      var xhr = $.ajax({ 
        url: conData.xmlUrl, 
        dataType: 'xml', 
        success: function(data) 
        {
          window.cachedTableData = _xmlToTable(data);
          retrieveDataCallback(window.cachedTableData);
        }
      });
      return;
    }
    try {
      var xmlDoc = $.parseXML(conData.xmlString);
      window.cachedTableData = _xmlToTable(xmlDoc);
    }
    catch (e) {
      tableau.log("unable to parse xml data");
      return;
    }
  }
  retrieveDataCallback(window.cachedTableData);
}

function _runXMLToTableTests() {
  // _findLongestsArray tests

  // _flattenObject tests

  // _extract headers test
}

function _xmlToTable(xmlDocument) {
  var rowData = _flattenData(xmlDocument);
  var headers = _extractHeaders(rowData);
  return {"headers":headers, "rowData":rowData};
}

function _flattenData(xmlDocument) {
  // first find the longest array
  var longestArray = _findLongestArray(xmlDocument, xmlDocument);
  if (!longestArray) {
    // if no array found, just wrap the entire object blob in an array
    longestArray = [objectBlob];
  }
  toRet = [];
  for (var ii = 0; ii < longestArray.childNodes.length; ++ii) {
    toRet[ii] = _flattenObject(longestArray.childNodes[ii]);
  }
  return toRet;
}

function _flattenObject(xmlElt) {
  var toRet = {};
  if (xmlElt.attributes)
  {
    for (var attributeNum = 0; attributeNum < xmlElt.attributes.length; ++attributeNum) {
      var attribute = xmlElt.attributes[attributeNum];
      toRet[attribute.nodeName] = attribute.nodeValue;
    }
  }
  
  var children = xmlElt.childNodes;
  if (!children || !children.length) {
    if (xmlElt.textContent) {
      toRet.text = xmlElt.textContent.trim();
    }
  } else {  
    for (var childNum = 0; childNum < children.length; ++childNum) {
      var child = xmlElt.childNodes[childNum];
      var childName = child.nodeName;

      var subObj = _flattenObject(child);
      for (var k in subObj) {
        if (subObj.hasOwnProperty(k)) {
          toRet[childName + '_' + k] = subObj[k];
        }
      }
    }
  }
  return toRet;
}

function _findLongestArray(xmlElement, bestSoFar) {
  var children = xmlElement.childNodes;
  if (children && children.length) {
    if (children.length > bestSoFar.childNodes.length) {
      bestSoFar = xmlElement;
    }
    for (var childNum in children) {
      var subBest = _findLongestArray(children[childNum], bestSoFar);
      if (subBest.childNodes.length > bestSoFar.childNodes.length) {
        bestSoFar = subBest;
      }
    }
  }
  return bestSoFar;
}

function _extractHeaders(rowData) {
  var toRet = {};
  for (var row = 0; row < rowData.length; ++row) {
    var rowLine = rowData[row];
    for (var key in rowLine) {
      if (rowLine.hasOwnProperty(key)) {
        if (!(key in toRet)) {
          toRet[key] = _determineType(rowLine[key]);
        }
      }
    }
  }
  return toRet;
}

function _determineType(primitive) {
  // possible types: 'float', 'date', 'datetime', 'bool', 'string', 'int'
  if (parseInt(primitive) == primitive) return 'int';
  if (parseFloat(primitive) == primitive) return 'float';
  if (isFinite(new Date(primitive).getTime())) return 'datetime';
  return 'string';
}

function _submitXMLToTableau(xmlString, xmlUrl) {
    var conData = {"xmlString" : xmlString, "xmlUrl": xmlUrl};
    tableau.connectionData = JSON.stringify(conData);
    console.write(tableau.connectionData);
    tableau.submit();  
}

$(document).ready(function(){
  $("#inputForm").submit(function(evt) { // This event fires when a button is clicked
    evt.preventDefault();
    var xmlString = $('textarea[name=xmlText]')[0].value.trim();
    var xmlUrl = $('input[name=xmlUrl]')[0].value.trim();
    _submitXMLToTableau(xmlString, xmlUrl);
  });

  var cancel = function (e) {    
      e.stopPropagation();
      e.preventDefault();
  }
  var ddHandler = $("#dragandrophandler");
  ddHandler.on('dragenter', function (e) 
  {
      cancel(e);
      $(this).css('border', '2px solid #0B85A1');
  }).on('dragover', cancel)
    .on('drop', function (e) 
  {
       $(this).css('border', '2px dashed #0B85A1');
       e.preventDefault();
       var files = e.originalEvent.dataTransfer.files;
       var file = files[0];
       var reader = new FileReader();
       reader.onload = function(e) { _submitXMLToTableau(reader.result); };
       reader.readAsText(file);
  });

  $(document).on('dragenter', cancel)
             .on('drop', cancel)
             .on('dragover', function (e) 
  {
    cancel(e);
    ddHandler.css('border', '2px dashed #0B85A1');
  });
});

</script>

<style>
#dragandrophandler {
  border:1px dashed #999;
  width:300px;
  color:#333;
  text-align:left;vertical-align:middle;
  padding:10px 10px 10 10px;
  margin:10px;
  font-size:150%;
}
</style>
</head>
<body>

<form id="inputForm" action="">
  Enter a URL for XML data: 
  <input type="text" name="xmlUrl" style="width: 400px;" />  
  <br>
  <div id="dragandrophandler">Or Drag & Drop Files Here</div>
  <br>
  Or paste XML data below
  <br>
  <textarea name="xmlText" rows="10" cols="70"/>
  </textarea>
  <input type="submit" value="Submit">
</form>

</body>
</html>